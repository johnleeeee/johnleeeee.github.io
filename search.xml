<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Redis基础简介</title>
      <link href="/2018/08/08/Redis%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/08/08/Redis%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h2 id="什么是redis？"><a href="#什么是redis？" class="headerlink" title="什么是redis？"></a>什么是redis？</h2><p>redis是一种内存中的数据结构存储系统，它可以用作数据库／缓存／消息中间件</p><h2 id="redis常见的作用？"><a href="#redis常见的作用？" class="headerlink" title="redis常见的作用？"></a>redis常见的作用？</h2><p>项目中使用redis作为缓存使用，这样可以减轻数据库的压力，同时可以加快一些常用数据的查询效率。对于查询多修改少的数据进行缓存。<br><a id="more"></a></p><h2 id="数据库中的数据与缓存中的数据如何实现同步？"><a href="#数据库中的数据与缓存中的数据如何实现同步？" class="headerlink" title="数据库中的数据与缓存中的数据如何实现同步？"></a>数据库中的数据与缓存中的数据如何实现同步？</h2><p>同步是同程序员代码来实现控制的。具体操作是：</p><ol><li>当缓存中不存在数据时，先去数据库查询，成功后更新缓存。</li><li>当缓存中存在数据时，首先更新缓存中的数据，同时会生成对应的修改操作的key一张记录表，之后redis后台会有相关的机制（待查。。。），读取该列表的保存的key，找到对应的数据，同步更新到数据库中。</li></ol><h2 id="缓存中的数据如何实现持久化操作？为什么要进行持久化操作？"><a href="#缓存中的数据如何实现持久化操作？为什么要进行持久化操作？" class="headerlink" title="缓存中的数据如何实现持久化操作？为什么要进行持久化操作？"></a>缓存中的数据如何实现持久化操作？为什么要进行持久化操作？</h2><p>redis中有完善的持久化策略。</p><ul><li>RDB（默认）：这种备份方式的效率最高，在规定的时间周期内为数据进行备份，如在多少秒内进行了多少次set操作则进行一次备份，保存在rdb文件中，当redis重启之后会根据配置文件找到对应的备份文件还原数据。</li><li>AOF：实时的持久化策略，性能相对较低。有三种模式：always：执行一次set就持久化一次。everysec每隔一秒进行一次持久化（常用）。no：持久化的时间由操作系统决定。（一般不配）<br>因为redis中的数据保存在内存中，如果出现宕机或断电的情况，会使内存中的数据丢失。如果是当作数据库和消息队列来使用时，这样的数据是绝不允许丢失的。</li></ul><h2 id="redis如何管理维护自身内存大小的？"><a href="#redis如何管理维护自身内存大小的？" class="headerlink" title="redis如何管理维护自身内存大小的？"></a>redis如何管理维护自身内存大小的？</h2><p>redis有6种内存优化管理的策略。</p><ol><li>lru：删除最近最少使用的数据</li><li>volatile-lru:删除设定了超时时间的数据中找最近最少使用的数据</li><li>allkey-lru：所有的key根据lru算法进行删除</li><li>volatile-random：在设定了超时时间的数据中进行随机删除</li><li>allkey-random：在所有的key中进行随机删除</li><li>volatile-ttl：在设置了超时时间的数据中删除，将要超时的数据</li><li>noevication：默认策略，不会进行删除，当进行set操作时会返回报错信息</li></ol><h2 id="缓存中的数据结构是怎样的？支持的数据类型有哪些？"><a href="#缓存中的数据结构是怎样的？支持的数据类型有哪些？" class="headerlink" title="缓存中的数据结构是怎样的？支持的数据类型有哪些？"></a>缓存中的数据结构是怎样的？支持的数据类型有哪些？</h2><p>redis数据是通过key-value方式进行存储的，redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合），zset（sorted set：有序集合）</p><h2 id="简述redis分片？为什么需要redis分片？"><a href="#简述redis分片？为什么需要redis分片？" class="headerlink" title="简述redis分片？为什么需要redis分片？"></a>简述redis分片？为什么需要redis分片？</h2><p>分片：根据某种规则…</p><p>分片的原因：</p><ol><li>redis内存满了，分片可实现动态扩容</li><li>redis服务器可能宕机，分片可以让每个节点保存一部分数据，宕机只会影响部分数据</li></ol><h2 id="简述redis哨兵机制？"><a href="#简述redis哨兵机制？" class="headerlink" title="简述redis哨兵机制？"></a>简述redis哨兵机制？</h2><p>使用哨兵机制实现redis的高可用。<br>哨兵机制实现原理：</p><ol><li>哨兵会主动给主机发送心跳检测，如果主机三次没有响应，则会推选出从机代替成为新的主机。</li><li>当新的主机被推选之后，会修改所有的主从配置文件，重新实现主从挂载。</li><li>客户端无需关注谁是主机，只需要通过哨兵操作redis。</li></ol><h2 id="redis中hash一致性？"><a href="#redis中hash一致性？" class="headerlink" title="redis中hash一致性？"></a>redis中hash一致性？</h2><ol><li>均衡性：尽可能的让数据均匀的落在不同的节点上。虚拟节点可以有效的平衡数据量</li><li>单调性：如果节点的数量发生改变，则需要进行重新运算，节点中的数据可以重新挂载</li><li>分散性：在分布式系统中，由于部分操作看不到全部的内存空间，相同的key落入不同的位置（指节点？？？）</li><li>负载：在分布式系统中，由于部分操作看不到全部的内存空间，不同的key落到同一个位置</li></ol><h2 id="redis集群搭建？"><a href="#redis集群搭建？" class="headerlink" title="redis集群搭建？"></a>redis集群搭建？</h2><p>1.修改配置文件redis.conf（设置绑定的ip端口／开启后台启动／pid文件路径（节点信息）／持久化文件路径／内存策略等等）／启动redis集群／添加节点信息7000.conf／添加超时时间<br>2.批量启动redis<br>3.使用ruby工具来构建集群（./src/redis-trib.rb create –replicas 2 集群ip+port）配置一主两从三个集群</p><h2 id="spring整合redis？"><a href="#spring整合redis？" class="headerlink" title="spring整合redis？"></a>spring整合redis？</h2><p>整合步骤：</p><ol><li>redis.properties中配置redis集群信息，在Spring文件中加载配置</li><li>配置Spring-redisCluster.xml文件，配置jedis配置jedisPoolConfig对象。</li><li>配置jedisCuster由于在xml文件中配置集群非常繁琐，所以我们采用实现spring中Bean的装配接口（BeanNameAware／BeanFactoryAware／InitializatingBean／FactoryBean<jediscluster>）及FactoryBean来实现bean的构建/或者直接在spring文件中配置HostAndPost</jediscluster></li><li>通过JedisCluster对象来操作redis</li></ol><h2 id="redis作为分布式锁的使用？"><a href="#redis作为分布式锁的使用？" class="headerlink" title="redis作为分布式锁的使用？"></a>redis作为分布式锁的使用？</h2><h2 id="redis作为消息队列使用？"><a href="#redis作为消息队列使用？" class="headerlink" title="redis作为消息队列使用？"></a>redis作为消息队列使用？</h2><p>场景：用户下单，将用户生成展示的订单先处理完成，其他操作，则存入消息队列中，这样可以更快的响应用户请求，体验更好。</p><h2 id="redis中常用的操作命令？"><a href="#redis中常用的操作命令？" class="headerlink" title="redis中常用的操作命令？"></a>redis中常用的操作命令？</h2><p>太多。看文档吧！</p><h2 id="redis缓存雪崩，缓存穿透，缓存并发？"><a href="#redis缓存雪崩，缓存穿透，缓存并发？" class="headerlink" title="redis缓存雪崩，缓存穿透，缓存并发？"></a>redis缓存雪崩，缓存穿透，缓存并发？</h2><ul><li>缓存穿透：<br>场景：缓存穿透是指使用不存在的key进行大量的高并发访问，导致缓存无法命中，造成数据库压力过大，甚至压死。<br>解决方案：<ol><li>将所有数据hash到一个大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉。</li><li>将空的结果也放入缓存中，但给它一个默认值，并设置一个很短的生存时间这样第二次再访问就有值了，就不会访问数据库了。</li></ol></li><li><p>缓存并发：<br>场景：在高并发场景下，当一个缓存的key过期时，而当前key的访问量比较大，多个请求同时发现缓存过期，因此会访问数据库，导致数据库压力过大。<br>解决方案：</p><ol><li>分布式锁</li><li>本地锁（当一个服务有多个节点时不适用）</li><li>软过期（在业务数据中存储过期时间信息，由业务程序判断是否过期并更新，发现数据将要过期时，延长缓存的时间，同时派遣另一条线程去数据库获取最新的数据）</li></ol></li><li><p>缓存雪崩：<br>场景：缓存服务器重启或者大量的缓存在同一时间段内失效，导致数据库瞬时压力过大。<br>解决方案：对不同的数据使用不同的失效时间，如基础时间上加一个随机时间。</p><hr><p>更详细的分析，以后再加……</p></li></ul><p><img src="http://wx2.sinaimg.cn/sq612/005AqIfAgy1fu2f631ch9j30k00k0wga.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> 分布式锁 </tag>
            
            <tag> nosql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/05/hello-world/"/>
      <url>/2018/08/05/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
        <tags>
            
            <tag> Testing </tag>
            
            <tag> Another Tag </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
