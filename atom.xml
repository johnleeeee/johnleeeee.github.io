<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>神圣的小白菜</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.keenlee.net/"/>
  <updated>2018-08-17T09:27:16.101Z</updated>
  <id>https://www.keenlee.net/</id>
  
  <author>
    <name>神圣的小白菜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis基础小结</title>
    <link href="https://www.keenlee.net/2018/08/08/Redis%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.keenlee.net/2018/08/08/Redis基础小结/</id>
    <published>2018-08-08T07:07:00.000Z</published>
    <updated>2018-08-17T09:27:16.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是redis？"><a href="#什么是redis？" class="headerlink" title="什么是redis？"></a>什么是redis？</h2><p>redis是一种内存中的数据结构存储系统，它可以用作数据库／缓存／消息中间件。</p><h2 id="redis常见的作用？"><a href="#redis常见的作用？" class="headerlink" title="redis常见的作用？"></a>redis常见的作用？</h2><p>项目中使用redis作为缓存使用，这样可以减轻数据库的压力，同时可以加快一些常用数据的查询效率。对于查询多修改少的数据进行缓存。<br><a id="more"></a></p><h2 id="数据库中的数据与缓存中的数据如何实现同步？"><a href="#数据库中的数据与缓存中的数据如何实现同步？" class="headerlink" title="数据库中的数据与缓存中的数据如何实现同步？"></a>数据库中的数据与缓存中的数据如何实现同步？</h2><p>同步是同程序员代码来实现控制的。具体操作是：</p><ol><li>当缓存中不存在数据时，先去数据库查询，成功后更新缓存。</li><li>当缓存中存在数据时，首先更新缓存中的数据，同时会生成对应的修改操作的key一张记录表，之后redis后台会有相关的机制（待查。。。），读取该列表的保存的key，找到对应的数据，同步更新到数据库中。</li></ol><h2 id="缓存中的数据如何实现持久化操作？为什么要进行持久化操作？"><a href="#缓存中的数据如何实现持久化操作？为什么要进行持久化操作？" class="headerlink" title="缓存中的数据如何实现持久化操作？为什么要进行持久化操作？"></a>缓存中的数据如何实现持久化操作？为什么要进行持久化操作？</h2><p>redis中有完善的持久化策略。</p><ul><li><p>RDB（默认）：这种备份方式的效率最高，在规定的时间周期内为数据进行备份，如在多少秒内进行了多少次set操作则进行一次备份，保存在rdb文件中，当redis重启之后会根据配置文件找到对应的备份文件还原数据。</p></li><li><p>AOF：实时的持久化策略，性能相对较低。有三种模式：</p><p>​    always：执行一次set就持久化一次。</p><p>​    everysec：每隔一秒进行一次持久化（常用）。</p><p>​    no：持久化的时间由操作系统决定。（一般不配）<br>因为redis中的数据保存在内存中，如果出现宕机或断电的情况，会使内存中的数据丢失。如果是当作数据库和消息队列来使用时，这样的数据是绝不允许丢失的。</p></li></ul><h2 id="redis如何管理维护自身内存大小的？"><a href="#redis如何管理维护自身内存大小的？" class="headerlink" title="redis如何管理维护自身内存大小的？"></a>redis如何管理维护自身内存大小的？</h2><p>redis有6种内存优化管理的策略。</p><ol><li>lru：删除最近最少使用的数据</li><li>volatile-lru:删除设定了超时时间的数据中找最近最少使用的数据</li><li>allkey-lru：所有的key根据lru算法进行删除</li><li>volatile-random：在设定了超时时间的数据中进行随机删除</li><li>allkey-random：在所有的key中进行随机删除</li><li>volatile-ttl：在设置了超时时间的数据中删除，将要超时的数据</li><li>noevication：默认策略，不会进行删除，当进行set操作时会返回报错信息</li></ol><h2 id="缓存中的数据结构是怎样的？支持的数据类型有哪些？"><a href="#缓存中的数据结构是怎样的？支持的数据类型有哪些？" class="headerlink" title="缓存中的数据结构是怎样的？支持的数据类型有哪些？"></a>缓存中的数据结构是怎样的？支持的数据类型有哪些？</h2><p>redis数据是通过key-value方式进行存储的。</p><p>redis支持五种基础数据类型：</p><p>string（字符串）：redis字符串是动态的，内部结构类似于Java的ArrayList，字符串最大长度为 512M 。</p><p>hash（哈希）：类似于Java的HashMap，数组+链表。不同的是字典的值只能是字符串，同时采用的是渐进式rehash策略。即保存了，新旧两个hash表，知道rehash全部完成，删除旧的。</p><p>hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。 hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。</p><p>list（列表）：类似于Java的LinkList（quickList），当列表元素较少时，采用ziplist（压缩列表）结构，连续的存储空间，节省存储空间，减轻内存碎片化 。当列表元素较多时，采用quicklist。将多个 <code>ziplist</code> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。 </p><p>set（集合）：类似于Java的HashSet，可用作全局去重</p><p>zset（sorted set：有序集合）：类似于SortedSet+HashMap，内部是跳跃列表的结构。</p><p>高级数据类型：HyperLogLog（），Geo、Pub/Sub （不成熟，基本被放弃），stream（5.0）支持消息订阅，想代替mq？</p><h2 id="简述redis分片？为什么需要redis分片？"><a href="#简述redis分片？为什么需要redis分片？" class="headerlink" title="简述redis分片？为什么需要redis分片？"></a>简述redis分片？为什么需要redis分片？</h2><p>分片：根据某种规则…</p><p>分片的原因：</p><ol><li>redis内存满了，分片可实现动态扩容</li><li>redis服务器可能宕机，分片可以让每个节点保存一部分数据，宕机只会影响部分数据</li></ol><h2 id="简述redis哨兵机制？"><a href="#简述redis哨兵机制？" class="headerlink" title="简述redis哨兵机制？"></a>简述redis哨兵机制？</h2><p>使用哨兵机制实现redis的高可用。<br>哨兵机制实现原理：</p><ol><li>哨兵会主动给主机发送心跳检测，如果主机三次没有响应，则会推选出从机代替成为新的主机。</li><li>当新的主机被推选之后，会修改所有的主从配置文件，重新实现主从挂载。</li><li>客户端无需关注谁是主机，只需要通过哨兵操作redis。</li></ol><h2 id="redis中hash一致性？"><a href="#redis中hash一致性？" class="headerlink" title="redis中hash一致性？"></a>redis中hash一致性？</h2><ol><li>均衡性：尽可能的让数据均匀的落在不同的节点上。虚拟节点可以有效的平衡数据量</li><li>单调性：如果节点的数量发生改变，则需要进行重新运算，节点中的数据可以重新挂载</li><li>分散性：在分布式系统中，由于部分操作看不到全部的内存空间，相同的key落入不同的位置</li><li>负载：在分布式系统中，由于部分操作看不到全部的内存空间，不同的key落到同一个位置</li></ol><h2 id="redis集群搭建？"><a href="#redis集群搭建？" class="headerlink" title="redis集群搭建？"></a>redis集群搭建？</h2><h2 id="spring整合redis？"><a href="#spring整合redis？" class="headerlink" title="spring整合redis？"></a>spring整合redis？</h2><h2 id="redis作为分布式锁的使用？"><a href="#redis作为分布式锁的使用？" class="headerlink" title="redis作为分布式锁的使用？"></a>redis作为分布式锁的使用？</h2><h6 id="什么是redis分布式锁"><a href="#什么是redis分布式锁" class="headerlink" title="什么是redis分布式锁"></a>什么是redis分布式锁</h6><p>在分布式环境中，保证不同节点的线程同步执行。</p><h6 id="分布式锁实现的三个核心："><a href="#分布式锁实现的三个核心：" class="headerlink" title="分布式锁实现的三个核心："></a>分布式锁实现的三个核心：</h6><p>​    1.加锁<br>    setnx（key , 1）<br>    当一个线程执行setnx返回1，说明原本的key不存在，该线程成功得到锁，否则说明该key已经存在，该线程抢锁失败。<br>    2.解锁<br>        del(key)<br>        释放锁之后，其他线程就可以继续执行setnx命令来获得锁<br>    3.超时锁<br>    1.为什么要有超时锁？<br>    答：当一个得到锁的线程在执行任务的过程中挂掉，来不及显示的释放锁，那么这块资源将会永远被锁住，其他线程再也无法进入了。<br>    setnx不支持超时参数，需要额外的指令：<br>    expire(key,30)</p><h6 id="redis分布式锁中三个致命的问题"><a href="#redis分布式锁中三个致命的问题" class="headerlink" title="redis分布式锁中三个致命的问题"></a>redis分布式锁中三个致命的问题</h6><p>​    场景一：<br>        当某个线程执行setnx,成功得到了锁，但此时该节点挂了，却还没来得及执行expire指令，这样也会导致锁一直无法释放，即它们的执行不是原子性的。<br>    解决：（版本2.6.12以上版本）<br>    set(key,1,30,NX)取代setnx指令<br>    场景二：<br>        假如A线程得到了锁，且成功得到了锁，并且设置了超时时间为30s,但如果A线程执行的很慢，超过30秒还没有执行完成，此时锁已经被超时释放，线程B获得了锁，当A执行完后，通过del指令来释放锁，但B线程还没有执行完，此时A线程把B现成的锁给释放了<br>    解决：可以在加锁的时候把当前线程的ID作为value，并在删除之前验证key对应的value是不是自己的线程ID。但是此时的判断和释放锁也不是原子性的，这里我们需要使用Lua脚本来实现，此时验证与释放为原子性操作了。<br>    String luaScript = “if redis.call(‘get’,KEY[1])==ARGV[1] then return redis.call(‘del’,KEYS) else return 0 end”<br>    redisClient.eval(luaScript,Collections.singletonList(key),Collections.singletonList(threadId));</p><p>线程ID在多个进程下不是全局唯一 。这里可以使用全局唯一的业务ID，或者在线程ID前加上机器id</p><p>​    场景三：在场景二中出现了两个线程访问同一个被锁的代码块的情况如何解决？<br>        解决：让获得锁的线程开启一个守护线程，当主线程快过期但还没有执行结束时，为其续航，当主线程真正执行完成后，再显示的关掉守护线程</p><pre><code>另一种更优雅的实现方式，Zookeeper分布式锁zookeeper的可靠性是要大于使用redis实现的分布式锁的，但是相比而言，redis的性能更好redis官方推荐分布式锁：Redission2.8.1的redisson需要jackson 2.5+版本</code></pre><p>参考自：微信公众号-程序员小灰</p><p>当一个线程请求加锁失败了怎么办？重试策略：</p><ol><li>直接抛出异常，通知用户稍后重试；</li><li>sleep 一会再重试；</li><li>将请求转移至延时队列，过一会再试；</li></ol><h2 id="redis作为消息队列使用？"><a href="#redis作为消息队列使用？" class="headerlink" title="redis作为消息队列使用？"></a>redis作为消息队列使用？</h2><p>场景：用户下单，将用户生成展示的订单先处理完成，其他操作，则存入消息队列中，这样可以更快的响应用户请求，体验更好。</p><h2 id="redis中常用的操作命令？"><a href="#redis中常用的操作命令？" class="headerlink" title="redis中常用的操作命令？"></a>redis中常用的操作命令？</h2><p><a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">http://www.redis.cn/commands.html</a></p><h2 id="缓存和数据库双写数据一致性如何保证？"><a href="#缓存和数据库双写数据一致性如何保证？" class="headerlink" title="缓存和数据库双写数据一致性如何保证？"></a>缓存和数据库双写数据一致性如何保证？</h2><p>数据的一致性，包括强一致性和最终一致性，要求强一致性，则不要使用缓存。最终一致性也只是降低不一致发生的概率，无法完全避免。</p><p>读取数据一般没啥问题，主要是更新数据。</p><p>三种策略：</p><p>1.先更新数据库，再更新缓存</p><p>问题：线程安全问题,多线程更新，并发情况下脏读。在写多读少的情况下，缓存频繁更新，但很少使用到，浪费性能。（不推荐）</p><p>2.先删除缓存，再更新数据库</p><p>并发场景下，A线程更新，B线程读取,A删除了缓存，还没来得及更新数据库，此时B查询缓存无数据，进而查询数据库，再更新缓存，这将导致缓存中的值永远为旧的值（不设置过期时间，或者回收的情况下）。</p><p>解决：延时双删策略：就是在A更新完数据库1S(根据业务逻辑时间)后，再次删除缓存（开启另外一个线程）</p><p>3.先更新数据库，再删除缓存</p><p>首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p><p>参考：<a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9041659.html</a> </p><p>4.先更新缓存，再更新数据库</p><p>淘宝的一个场景读多写多 ，sql无序，使用过。</p><p>《从P1到P7——我在淘宝这7年》这篇博客原文 ：</p><p>在【招财进宝】项目中有一个技术的细节值得拿出来说说，淘宝商品详情页面每天的流量在10亿以上，里面的内容都是放在缓存里的，做【招财进宝】的时候，我们要给卖家显示他的商品被浏览的次数，这个数字必须实时更新，而用缓存的话一般都是异步更新的。于是商品表里面增加了这样一个字段，每增加一个PV这个字段就要更新一次。发布上去一个小时数据库就挂掉了，撑不住这么高的update。数据库撑不住怎么办？一般的缓存策略是不支持实时更新的，这时候多隆大神想了个办法，在apache上面写了一个模块，这个数字根本不经过下层的web容器（只经过apache）就写入一个集中式的缓存区了，这个缓存区的数据再异步更新到数据库。好像什么问题，到了多隆手里，总能迎刃而解。 </p><h2 id="redis是单线程的为什么那么快？"><a href="#redis是单线程的为什么那么快？" class="headerlink" title="redis是单线程的为什么那么快？"></a>redis是单线程的为什么那么快？</h2><ul><li><p>纯内存操作</p></li><li><p>单线程操作，避免了上下文的切换</p></li><li><p>采用了非阻塞式I/O多路复用机制（NIO）</p></li></ul><p>  参考：<a href="https://www.cnblogs.com/rjzheng/p/9096228.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9096228.html</a></p><h2 id="redis缓存雪崩，缓存穿透，缓存并发？"><a href="#redis缓存雪崩，缓存穿透，缓存并发？" class="headerlink" title="redis缓存雪崩，缓存穿透，缓存并发？"></a>redis缓存雪崩，缓存穿透，缓存并发？</h2><ul><li>缓存穿透：<br>场景：缓存穿透是指使用不存在的key进行大量的高并发访问，导致缓存无法命中，造成数据库压力过大，甚至压死。<br>解决方案：<ol><li>将所有数据hash到一个大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉。</li><li>将空的结果也放入缓存中，但给它一个默认值，并设置一个很短的生存时间这样第二次再访问就有值了，就不会访问数据库了。</li></ol></li><li><p>缓存并发：<br>场景：在高并发场景下，当一个缓存的key过期时，而当前key的访问量比较大，多个请求同时发现缓存过期，因此会访问数据库，导致数据库压力过大。<br>解决方案：</p><ol><li>分布式锁</li><li>本地锁（当一个服务有多个节点时不适用）</li><li>软过期（在业务数据中存储过期时间信息，由业务程序判断是否过期并更新，发现数据将要过期时，延长缓存的时间，同时派遣另一条线程去数据库获取最新的数据）</li></ol></li><li><p>缓存雪崩：<br>场景：缓存服务器重启或者大量的缓存在同一时间段内失效，导致数据库瞬时压力过大。<br>解决方案：对不同的数据使用不同的失效时间，如基础时间上加一个随机时间。</p><hr></li></ul><p><img src="http://wx2.sinaimg.cn/sq612/005AqIfAgy1fu2f631ch9j30k00k0wga.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是redis？&quot;&gt;&lt;a href=&quot;#什么是redis？&quot; class=&quot;headerlink&quot; title=&quot;什么是redis？&quot;&gt;&lt;/a&gt;什么是redis？&lt;/h2&gt;&lt;p&gt;redis是一种内存中的数据结构存储系统，它可以用作数据库／缓存／消息中间件。&lt;/p&gt;
&lt;h2 id=&quot;redis常见的作用？&quot;&gt;&lt;a href=&quot;#redis常见的作用？&quot; class=&quot;headerlink&quot; title=&quot;redis常见的作用？&quot;&gt;&lt;/a&gt;redis常见的作用？&lt;/h2&gt;&lt;p&gt;项目中使用redis作为缓存使用，这样可以减轻数据库的压力，同时可以加快一些常用数据的查询效率。对于查询多修改少的数据进行缓存。&lt;br&gt;
    
    </summary>
    
      <category term="架构" scheme="https://www.keenlee.net/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="redis" scheme="https://www.keenlee.net/tags/redis/"/>
    
      <category term="缓存" scheme="https://www.keenlee.net/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="消息队列" scheme="https://www.keenlee.net/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="分布式锁" scheme="https://www.keenlee.net/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
</feed>
